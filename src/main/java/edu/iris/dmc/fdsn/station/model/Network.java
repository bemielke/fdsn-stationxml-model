//
// This file was generated by the JavaTM Architecture for XML Binding(JAXB) Reference Implementation, v2.2.5-b10 
// See <a href="http://java.sun.com/xml/jaxb">http://java.sun.com/xml/jaxb</a> 
// Any modifications to this file will be lost upon recompilation of the source schema. 
// Generated on: 2012.11.05 at 01:15:36 PM PST 
//

package edu.iris.dmc.fdsn.station.model;

import java.math.BigInteger;
import java.util.ArrayList;
import java.util.List;
import javax.xml.bind.annotation.XmlAccessType;
import javax.xml.bind.annotation.XmlAccessorType;
import javax.xml.bind.annotation.XmlElement;
import javax.xml.bind.annotation.XmlType;


/**
 * This type represents the Network layer, all station metadata is contained
 * within this element. The official name of the network or other descriptive
 * information can be included in the Description element. The Network can
 * contain 0 or more Stations.
 * 
 * <p>
 * Java class for NetworkType complex type.
 * 
 * <p>
 * The following schema fragment specifies the expected content contained within
 * this class.
 * 
 * <pre>
 * &lt;complexType name="NetworkType">
 *   &lt;complexContent>
 *     &lt;extension base="{http://www.fdsn.org/xml/station/1}BaseNodeType">
 *       &lt;sequence>
 *         &lt;element name="TotalNumberStations" type="{http://www.fdsn.org/xml/station/1}CounterType" minOccurs="0"/>
 *         &lt;element name="SelectedNumberStations" type="{http://www.fdsn.org/xml/station/1}CounterType" minOccurs="0"/>
 *         &lt;element name="Station" type="{http://www.fdsn.org/xml/station/1}StationType" maxOccurs="unbounded" minOccurs="0"/>
 *       &lt;/sequence>
 *       &lt;anyAttribute processContents='lax' namespace='##other'/>
 *     &lt;/extension>
 *   &lt;/complexContent>
 * &lt;/complexType>
 * </pre>
 * 
 * 
 */

@XmlAccessorType(XmlAccessType.FIELD)
@XmlType(name = "NetworkType", propOrder = {
    "totalNumberStations",
    "selectedNumberStations",
    "station"
})
public class Network
    extends BaseNodeType
{

    @XmlElement(name = "TotalNumberStations")
    protected BigInteger totalNumberStations;
    @XmlElement(name = "SelectedNumberStations")
    protected BigInteger selectedNumberStations;
    @XmlElement(name = "Station")
    protected List<Station> station;
    


	/**
	 * Gets the value of the totalNumberStations property.
	 * 
	 * @return possible object is {@link BigInteger }
	 * 
	 */
	public BigInteger getTotalNumberStations() {
		return totalNumberStations;
	}

	/**
	 * Sets the value of the totalNumberStations property.
	 * 
	 * @param value
	 *            allowed object is {@link BigInteger }
	 * 
	 */
	public void setTotalNumberStations(BigInteger value) {
		this.totalNumberStations = value;
	}

	/**
	 * Gets the value of the selectedNumberStations property.
	 * 
	 * @return possible object is {@link BigInteger }
	 * 
	 */
	public BigInteger getSelectedNumberStations() {
		return selectedNumberStations;
	}

	/**
	 * Sets the value of the selectedNumberStations property.
	 * 
	 * @param value
	 *            allowed object is {@link BigInteger }
	 * 
	 */
	public void setSelectedNumberStations(BigInteger value) {
		this.selectedNumberStations = value;
	}

	/**
	 * Gets the value of the station property.
	 * 
	 * <p>
	 * This accessor method returns a reference to the live list, not a
	 * snapshot. Therefore any modification you make to the returned list will
	 * be present inside the JAXB object. This is why there is not a
	 * <CODE>set</CODE> method for the station property.
	 * 
	 * <p>
	 * For example, to add a new item, do as follows:
	 * 
	 * <pre>
	 * getStation().add(newItem);
	 * </pre>
	 * 
	 * 
	 * <p>
	 * Objects of the following type(s) are allowed in the list {@link Station }
	 * 
	 * 
	 */
	public List<Station> getStation() {
		return this.station;
	}

	public void addStation(Station station) {
		if (station == null) {
			return;
		}

		if (this.station == null) {
			this.station = new ArrayList<Station>();
		}
		
		station.setNetwork(this);
		this.station.add(station);
	}
	
	
	
	public void merge(Station station) {
		if (station == null) {
			return;
		}

		if (this.station == null) {
			this.station = new ArrayList<Station>();
			this.addStation(station);
			return;
		}
		station.setNetwork(this);

		int index = this.station.indexOf(station);

		
		if(index<0){
			this.addStation(station);
		}else{
			Station s = this.station.get(index);
			for(Channel c:station.getChannel()){
				s.merge(c);
			}
		}
	}
	@Override
	public int hashCode() {
		final int prime = 31;
		int result = 1;
		result = prime * result + ((code == null) ? 0 : code.hashCode());
		return result;
	}

	@Override
	public boolean equals(Object obj) {
		if (this == obj)
			return true;
		if (obj == null)
			return false;
		if (getClass() != obj.getClass())
			return false;
		Network other = (Network) obj;
		if (code == null) {
			if (other.code != null)
				return false;
		} else if (!code.equals(other.code))
			return false;
		
		if(description==null){
			if (other.description != null)
				return false;
		} else if (!description.equals(other.description))
			return false;		
		
		if (this.getStartTime() == null) {
			if (other.getStartTime() != null)
				return false;
		} else if (!getStartTime().equals(other.getStartTime()))
			return false;
		
		if (this.getEndTime() == null) {
			if (other.getEndTime() != null)
				return false;
		} else if (!getEndTime().equals(other.getEndTime()))
			return false;

		return true;
	}

	@Override
	public String toString() {
		return "Network [code=" + code + "]";
	}
	
	
}
